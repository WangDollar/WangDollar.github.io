[{"id":"98d02bf82cf59f56a861db64adcd055d","title":"随笔待定","content":"待完善待完善这里将记录一些日常的思考和感悟…\n","slug":"thoughts_1","date":"2025-01-16T14:00:00.000Z","categories_index":"随笔","tags_index":"随笔","author_index":"Dollar"},{"id":"d44f5b4becde69762048764f7a6b72f0","title":"经验帖汇总","content":"经验贴汇总SUDA\n（25级）原文链接\n\n背景：低rank+弱科研+弱竞赛+低六级+四非鼠\n去向：苏州大学计算机科学与技术（学硕）\n\n\n待补充…\n\n\nNJU\n待补充…\n\nSEU\n待补充…\n\nNUAA\n待补充…\n\nNJUST\n待补充…\n\nTHU\n（邢神）原文链接\n背景：佬\n去向：清华大学深圳研究院IMDT\n\n\n\n其他院校\n待补充…\n\n\n\n\n\n\n\n\n\n\n注：本文持续更新中，欢迎投稿分享经验\n","slug":"postgraduate_experience","date":"2025-01-16T13:30:00.000Z","categories_index":"保研","tags_index":"保研","author_index":"Dollar"},{"id":"f65c2271ed43cdf14e2eea3c0c440d44","title":"前缀和与差分","content":"前缀和与差分算法思想\n前缀和\n\n对原数组求前缀和，得到新数组\n通过新数组O(1)时间得到任意区间和\n一维前缀和：S[i] &#x3D; a[1] + a[2] + … + a[i]\n二维前缀和：S[i,j] &#x3D; 左上角子矩阵的和\n\n\n差分\n\n前缀和的逆运算\n对区间统一加减某个数\n对原数组求差分，得到新数组\n新数组的前缀和就是原数组\n\n\n\n实现方法\n一维前缀和\n\n预处理前缀和数组\n区间和 &#x3D; S[r] - S[l-1]\n\n\n二维前缀和\n\n预处理二维前缀和数组\n子矩阵和 &#x3D; S[x2,y2] - S[x2,y1-1] - S[x1-1,y2] + S[x1-1,y1-1]\n\n\n一维差分\n\n构建差分数组：B[i] &#x3D; A[i] - A[i-1]\n区间增减：B[l] +&#x3D; c, B[r+1] -&#x3D; c\n还原原数组：A[i] &#x3D; B[1] + B[2] + … + B[i]\n\n\n二维差分\n\n构建差分矩阵：B[i,j] &#x3D; A[i,j] - A[i-1,j] - A[i,j-1] + A[i-1,j-1]\n子矩阵增减：B[x1,y1] +&#x3D; c, B[x2+1,y1] -&#x3D; c, B[x1,y2+1] -&#x3D; c, B[x2+1,y2+1] +&#x3D; c\n还原原矩阵：A[i,j] &#x3D; 前缀和(B[1i,1j])\n\n\n\n复杂度分析\n前缀和预处理：O(n)或O(n²)\n前缀和查询：O(1)\n差分构建：O(n)或O(n²)\n差分区间操作：O(1)\n差分还原：O(n)或O(n²)\n\n经典题目\n前缀和\n\nAcWing 795：一维前缀和模板题\n\n\n子矩阵的和\n\nAcWing 796：二维前缀和模板题\n\n\n差分\n\nAcWing 797：差分模板题\n\n\n差分矩阵\n\nAcWing 798：二维差分模板题\n\n\n\n应用场景\n区间查询\n\n快速求解区间和\n统计区间内的特定元素个数\n\n\n区间修改\n\n对区间统一加减\n航班订票系统\n差分图像处理（二维差分）\n区域亮度调整\n地图高度修改\n\n\n\n注意事项\n数组下标\n\n从1开始更方便处理\n注意边界情况\n\n\n空间优化\n\n可以直接在原数组上构建前缀和\n差分数组可以复用原数组\n\n\n应用技巧\n\n前缀和可以维护多个信息\n差分适合大量区间修改操作\n二维操作注意子矩阵的边界处理\n二维差分的四个角要配对操作\n\n\n\n代码模板cpp// 一维前缀和\nvoid prefix_sum_1d() &#123;\n    // S[0] = 0;\n    for (int i = 1; i &lt;= n; i ++ )\n        S[i] = S[i - 1] + a[i];\n    // 查询区间[l,r]的和\n    // S[r] - S[l - 1]\n&#125;\n\n// 二维前缀和\nvoid prefix_sum_2d() &#123;\n    for (int i = 1; i &lt;= n; i ++ )\n        for (int j = 1; j &lt;= m; j ++ )\n            S[i][j] = S[i-1][j] + S[i][j-1] - S[i-1][j-1] + a[i][j];\n    // 查询子矩阵和[(x1,y1), (x2,y2)]\n    // S[x2][y2] - S[x2][y1-1] - S[x1-1][y2] + S[x1-1][y1-1]\n&#125;\n\n// 一维差分\nvoid diff_1d() &#123;\n    // 构建差分数组\n    for (int i = 1; i &lt;= n; i ++ ) \n        b[i] = a[i] - a[i - 1];\n    // 区间[l,r]加上c\n    void add(int l, int r, int c) &#123;\n        b[l] += c;\n        b[r + 1] -= c;\n    &#125;\n    // 还原原数组\n    for (int i = 1; i &lt;= n; i ++ ) \n        a[i] = a[i - 1] + b[i];\n&#125;\n\n// 二维差分\nvoid diff_2d() &#123;\n    // 构建差分矩阵\n    for (int i = 1; i &lt;= n; i++) \n        for (int j = 1; j &lt;= m; j++) \n            b[i][j] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1];\n  \n    // 子矩阵[x1,y1,x2,y2]加上c\n    void add(int x1, int y1, int x2, int y2, int c) &#123;\n        b[x1][y1] += c;\n        b[x2 + 1][y1] -= c;\n        b[x1][y2 + 1] -= c;\n        b[x2 + 1][y2 + 1] += c;\n    &#125;\n  \n    // 还原原矩阵\n    for (int i = 1; i &lt;= n; i++) \n        for (int j = 1; j &lt;= m; j++) \n            a[i][j] = a[i-1][j] + a[i][j-1] - a[i-1][j-1] + b[i][j];\n&#125;","slug":"prefix_sum","date":"2025-01-15T13:00:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"Dollar"},{"id":"b12e6a1f5d7efc2ae0896995e35e825f","title":"高精度运算","content":"高精度运算算法思想高精度运算用于处理超出常规整型范围的数值计算：\n\n用数组存储大整数，每一位对应一个数组元素\n按照竖式运算的方式模拟运算过程\n需要处理进位和借位\n注意结果的正确性和前导零的处理\n\n实现方法常见的高精度运算包括：\n\n高精度加法\n\n从低位到高位逐位相加\n处理进位\n最高位可能需要进位\n\n\n高精度减法\n\n从低位到高位逐位相减\n处理借位\n需要判断结果的正负\n\n\n高精度乘法\n\n可以是高精度乘以单精度\n也可以是高精度乘以高精度\n注意结果的位数\n\n\n高精度除法\n\n通常是高精度除以单精度\n从高位到低位逐位除\n需要处理余数的传递\n\n\n\n复杂度分析\n加法和减法：O(n)，n为较长数的位数\n乘法：O(n×m)，n和m为两个数的位数\n除法：O(n)，n为被除数的位数\n空间复杂度：O(n)或O(n+m)\n\n经典题目\n高精度加法\n\nAcWing 791：实现任意长度正整数相加\n\n\n高精度减法\n\nAcWing 792：实现任意长度正整数相减\n\n\n高精度乘法\n\nAcWing 793：高精度数乘以单精度数\n\n\n高精度除法\n\nAcWing 794：高精度数除以单精度数\n\n\n\n代码模板cpp// 高精度加法\nvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0; i &lt; A.size() || i &lt; B.size(); i ++ )\n    &#123;\n        if (i &lt; A.size()) t += A[i];\n        if (i &lt; B.size()) t += B[i];\n        C.push_back(t % 10);\n        t /= 10;\n    &#125;\n    if (t) C.push_back(t);\n    return C;\n&#125;\n\n// 高精度减法\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)\n&#123;\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0; i &lt; A.size(); i ++ )\n    &#123;\n        t = A[i] - t;\n        if (i &lt; B.size()) t -= B[i];\n        C.push_back((t + 10) % 10);\n        t = t &lt; 0;\n    &#125;\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n&#125;\n\n// 高精度乘单精度\nvector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)\n&#123;\n    vector&lt;int&gt; C;\n    int t = 0;\n    for (int i = 0; i &lt; A.size() || t; i ++ )\n    &#123;\n        if (i &lt; A.size()) t += A[i] * b;\n        C.push_back(t % 10);\n        t /= 10;\n    &#125;\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n&#125;\n\n// 高精度除以单精度\nvector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)\n&#123;\n    vector&lt;int&gt; C;\n    r = 0;\n    for (int i = A.size() - 1; i &gt;= 0; i -- )\n    &#123;\n        r = r * 10 + A[i];\n        C.push_back(r / b);\n        r %= b;\n    &#125;\n    reverse(C.begin(), C.end());\n    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();\n    return C;\n&#125;","slug":"high_precision","date":"2025-01-15T12:30:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"Dollar"},{"id":"d843ced03f40ac612213952de4b63ad2","title":"二分查找","content":"二分查找算法思想二分查找的核心思想是：\n\n每次将区间分成两部分\n判断目标值在哪个区间\n舍弃不可能的区间\n不断缩小范围直到找到目标值\n\n实现方法二分查找有两种常见模板：\n\n整数二分\n\n区间[l, r]被划分成[l, mid]和[mid + 1, r]\n更新时，l &#x3D; mid + 1或r &#x3D; mid\n\n\n浮点数二分\n\n直接取mid &#x3D; (l + r) &#x2F; 2\n更新时，l &#x3D; mid或r &#x3D; mid\n通过判断精度来结束循环\n\n\n\n复杂度分析\n时间复杂度：O(logn)\n空间复杂度：O(1)\n要求：序列必须有序\n\n经典题目\n数的范围\n\nAcWing 789：在有序数组中找到目标值的起始和结束位置\n\n\n数的三次方根\n\nAcWing 790：浮点数二分的典型应用\n\n\n\n应用场景\n在有序序列中查找元素\n求解最大值最小化问题\n求解最小值最大化问题\n求解平方根、立方根等数值计算问题\n\n代码模板cppint SL(int l, int r, int x)\n&#123;\n    while(l &lt; r)\n    &#123;\n        int mid = l + r &gt;&gt; 1;\n        if(q[mid] &gt;= x) r = mid;\n        else l = mid + 1;\n    &#125;\n    return l;\n&#125;\nint SR(int l, int r, int x)\n&#123;\n    while(l &lt; r)\n    &#123;\n        int mid = l + r + 1&gt;&gt; 1;\n        if(q[mid] &lt;= x) l = mid;\n        else r = mid - 1;\n    &#125;\n    return r;\n&#125;\n","slug":"binary_search","date":"2025-01-15T12:00:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"Dollar"},{"id":"c668d79bcd807cc57a11ce29c7e08a39","title":"归并排序","content":"归并排序算法思想归并排序的核心思想是分治法：\n\n将数组平均分成两个子数组\n递归排序左右两个子数组\n将两个有序的子数组合并成一个有序数组\n不断重复这个过程，直到整个数组有序\n\n实现方法采用双指针技巧实现合并：\n\n开辟一个临时数组存储合并结果\n两个指针分别指向两个子数组的开头\n比较两个指针指向的元素，将较小的放入临时数组\n重复步骤3直到某个子数组处理完\n将剩余元素复制到临时数组\n\n复杂度分析\n时间复杂度：O(nlogn)\n空间复杂度：O(n)\n稳定排序\n\n经典题目\n归并排序模板题\n\nAcWing 787：实现基础的归并排序\n\n\n逆序对的数量\n\nAcWing 788：归并排序的经典应用\n\n\n\n应用场景\n求解逆序对问题\n链表排序（空间效率高）\n外部排序（适合大文件排序）\n区间合并问题\n\n代码模板cppvoid merge_sort(int q[], int l, int r)\n&#123;\n    if (l &gt;= r) return;\n  \n    int mid = l + r &gt;&gt; 1;\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n  \n    int k = 0, i = l, j = mid + 1;\n    while (i &lt;= mid &amp;&amp; j &lt;= r)\n        if (q[i] &lt;= q[j]) tmp[k++] = q[i++];\n        else tmp[k++] = q[j++];\n    \n    while (i &lt;= mid) tmp[k++] = q[i++];\n    while (j &lt;= r) tmp[k++] = q[j++];\n  \n    for (i = l, j = 0; i &lt;= r; i++, j++) q[i] = tmp[j];\n&#125;","slug":"merge_sort","date":"2025-01-15T11:30:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"Dollar"},{"id":"9c04d15496da1d73edddda137155e866","title":"快速排序","content":"快速排序算法思想快速排序的核心思想是分治法：\n\n选择一个基准数（pivot）将数组分为两部分\n左部分的所有元素小于基准数\n右部分的所有元素大于基准数\n递归处理左右两部分，直到数组完全有序\n\n实现方法采用双指针技巧实现划分：\n\n一个指针从数组头部向右扫描\n一个指针从数组尾部向左扫描\n找到不满足条件的元素就交换\n直到两个指针相遇完成一次划分\n\n复杂度分析\n时间复杂度：O(nlogn)\n空间复杂度：O(logn)\n不稳定排序\n\n经典题目\n快速排序模板题\n\nAcWing 785：实现基础的快速排序\n\n\n第K个数\n\nAcWing 786：快速选择算法的应用\n\n\n\n代码模板cppint SL(int l, int r, int x)\n&#123;\n    while(l &lt; r)\n    &#123;\n        int mid = l + r &gt;&gt; 1;\n        if(q[mid] &gt;= x) r = mid;\n        else l = mid + 1;\n    &#125;\n    return l;\n&#125;\nint SR(int l, int r, int x)\n&#123;\n    while(l &lt; r)\n    &#123;\n        int mid = l + r + 1&gt;&gt; 1;\n        if(q[mid] &lt;= x) l = mid;\n        else r = mid - 1;\n    &#125;\n    return r;\n&#125;","slug":"quick_sort","date":"2025-01-15T10:46:53.000Z","categories_index":"算法","tags_index":"算法","author_index":"Dollar"}]